const path = require('path');
const fs = require('fs');
const yaml = require('yaml');
const webpack = require('webpack');
const WebpackAssetsManifest = require('webpack-assets-manifest');
const IgnoreEmitPlugin = require('ignore-emit-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const { ProvidePlugin } = require('webpack');

const simofaConfig = yaml.parse(fs.readFileSync(path.join(__dirname, 'config.yml'), {
    encoding: 'utf-8'
}));
const devMode = process.env.MODE === 'production' ? false : !!simofaConfig.simofa_internals.dev;
if (devMode) {
	console.log('RUNNING IN DEV MODE');
}

const BASE_PATH = path.join(__dirname, 'simofa', 'src', 'main', 'resources', 'web', 'assets');

const jsBase = path.join(BASE_PATH, 'js');
const imgBase = path.join(BASE_PATH, 'img');
const cssBase = path.join(BASE_PATH, 'css');
const outBase = path.join(BASE_PATH, 'build');

function getDirFiles(base, dir = null) {
	let files = [];
	let fullDir = dir ? path.join(base, dir) : base;
	
	if (devMode) {
		files.push('webpack-dev-server/client');
		files.push('webpack/hot/only-dev-server');
	}

	fs.readdirSync(fullDir).forEach(e => {
		if (fs.statSync(path.join(fullDir, e)).isFile()) {
			files.push(dir ? `${dir}/${e}` : e);
		} else {
			files.push(...getDirFiles(base, dir ? path.join(dir, e) : e));
		}
	});

	// Normalise slashes
	return files.map(e => e.replace('\\', '/'));
}

/** @type {import('webpack').Configuration} */
const jsFiles = {
	mode: devMode ? 'development' : 'production',
	entry: getDirFiles(jsBase)
		.filter(e => e.endsWith('.js') || e.endsWith('.jsx') || e.endsWith('.tsx'))
		.filter(e => !e.match(/\/_/g))
		.reduce((a, e) => ({ ...a, [e.replace(/\.(j|t)sx?$/, '')]: path.join(jsBase, e) }), {}),
	output: {
		path: path.join(outBase, 'js'),
		filename: '[name].[contenthash:8].js',
		chunkFilename: '[name].[chunkhash:8].chunk.js',
		clean: true,
		chunkLoadingGlobal: 'webpackChunk'
	},
	devServer: {
		hot: devMode,
		/*proxy: {
			'/': {
				target: {
					host: 'localhost',
					protocol: 'http:',
					port: simofaConfig.port || 8808
				}
			}
		},*/
		devMiddleware: {
			writeToDisk: true
		}
	},
	cache: true,
	experiments: {
		topLevelAwait: true
	},
	resolve: {
	    extensions: [
            '.js',
            '.jsx',
            '.ts',
            '.tsx',
            '.d.ts'
	    ],
	    alias: {
            "react": "preact/compat",
            "react-dom/test-utils": "preact/test-utils",
            "react-dom": "preact/compat",     // Must be below test-utils
            "react/jsx-runtime": "preact/jsx-runtime"
	    }
	},
	module: {
		rules: [
			{
				test: /\.(j|t)sx?$/,
				exclude: /\.d\.ts$/,
				use: [
                    {
                        loader: 'ts-loader',
                        options: {
                            configFile: path.join(jsBase, 'tsconfig.json')
                        }
                    },
					{
					    loader: 'babel-loader'
                    }
				]
			},
			{
                test: /\.d\.ts$/,
                loader: 'ignore-loader'
            },
			{
                test: /\.css$/,
                use: [
					MiniCssExtractPlugin.loader,
                    {
                        loader: '@teamsupercell/typings-for-css-modules-loader',
                        options: {
                            banner: "// autogenerated by typings-for-css-modules-loader. \n// Please do not change this file!"
                        }
                    },
                    {
                        loader: 'css-loader',
                        options: {
                            modules: {
                                localIdentName: '[local]_[hash:base64:8]'
                            }
                        }
                    },
                    'postcss-loader'
                ]
            }
		]
	},
	optimization: {
		minimize: !devMode,
		minimizer: [
			new TerserPlugin({
				test: /\.js$/,
				extractComments: false,
				terserOptions: {
					format: {
						comments: false
					}
				}
			}),
			new CssMinimizerPlugin({
				include: /\.css$/,
				minimizerOptions: {
					preset: [
						'default',
						{
							discardComments: {
								removeAll: true
							}
						}
					]
				}
			})
		],
		runtimeChunk: 'single',
		splitChunks: {
			minSize: 5000,
			minRemainingSize: 0,
			minChunks: 1,
			maxAsyncRequests: 30,
			maxInitialRequests: 30,
			enforceSizeThreshold: 15000,
			maxInitialSize: 15000,
			cacheGroups: {
				defaultVendors: {
					test: /[\\/]node_modules[\\/]/,
					name(module) {
						if (!module.context.includes('node_modules')) return 'vendor';
						const packageName = module.context.match(
							/[\\/]node_modules[\\/](.*?)([\\/]|$)/
						)[1];
						
						// While it's nice having separate files for different packages to help with caching
						// and cache invalidation when a package's code changes, there's no need to publish
						// what these packages are. Hashing helps achieve this goal in a deterministic way
						// while still allowing me to determine what package it is when troubleshooting.
						const packageNameHash = require('crypto').createHash('sha256').update(packageName).digest('hex').substr(0, 4);
						return `vendor.npm-${packageNameHash}`;
					},
					priority: -10,
					reuseExistingChunk: true,
				},
				default: {
					minChunks: 2,
					priority: -20,
					reuseExistingChunk: true,
				}
			}
		}
	},
	plugins: [
		//new WebpackAssetsManifest(),
		new ProvidePlugin({
			React: devMode ? path.join(jsBase, 'react', '_common', '_preact-debug.js') : 'react'
		}),
		new MiniCssExtractPlugin({
			filename: '../css/[name].[contenthash:8].css'
		})
	]
};

const imgFiles = {
	mode: 'production',
	entry: {
		images: fs.readdirSync(imgBase, 'utf-8').map(e => path.join(imgBase, e))
	},
	output: {
		path: path.join(outBase, 'img'),
		filename: 'webpack-generated.ignore',
		clean: true,
	},
	module: {
		rules: [
			{
				test: /\.(png|jpg)$/,
				type: 'asset/resource',
				generator: {
					filename: '[name].[contenthash:8][ext]'
				}
			}
		]
	},
	plugins: [
		new IgnoreEmitPlugin(/\.ignore$/),
	]
};

const cssFiles = {
	mode: 'production',
	entry: getDirFiles(cssBase)
		.filter(e => e.endsWith('.css') || e.endsWith('.scss'))
		.reduce((a, e) => ({ ...a, [e.replace(/\.s?css$/, '')]: path.join(cssBase, e) }), {}),
	output: {
		path: path.join(outBase, 'css'),
		filename: 'webpack-generated-[name].ignore',
		clean: true
	},
	module: {
		rules: [
			{
				test: /\.js$/,
				loader: 'babel-loader',
			},
			{
				test: /\.css$/,
				use: [
					MiniCssExtractPlugin.loader,
					'css-loader',
					'postcss-loader'
				]
			},
			{
			    test: /\.scss$/,
			    use: [
			        MiniCssExtractPlugin.loader,
			        'css-loader',
			        'sass-loader',
			        'postcss-loader'
			    ]
			}
		]
	},
	optimization: {
		splitChunks: {
			cacheGroups: {
				styles: {
					name(module, chunks) {
						return chunks[0].name;
					},
					test: /\.css$/,
					chunks: 'all',
					enforce: true,
				},
			},
		},
		minimize: true,
		minimizer: [
			new CssMinimizerPlugin({
				include: /\.css$/
			})
		]
	},
	plugins: [
		new IgnoreEmitPlugin(/\.ignore$/),
		new MiniCssExtractPlugin({
			filename: '[name].[contenthash:8].css',
		})
	]
};


const webFiles = [
	jsFiles,
	//imgFiles,
	cssFiles
];

if (fs.existsSync(path.join(outBase, 'assets-manifest.json'))) {
	fs.unlinkSync(path.join(outBase, 'assets-manifest.json'));
}
for (let i = 0; i < webFiles.length; i++) {
	if (!webFiles[i].plugins) {
		webFiles[i].plugins = [];
	}

	let manifestPrefix = webFiles[i].output.path
		.replace(outBase, '')
		.replace(new RegExp(`^\\${path.sep}`), '');

	webFiles[i].plugins.push(new WebpackAssetsManifest({
		merge: true,
		customize(entry) {
			let e = {
				//key: `${manifestPrefix}/${entry.key}`,
				key: entry.key.startsWith('../') ? entry.key.replace(/^\.\.\//, '') : `${manifestPrefix}/${entry.key}`,
				// Without this, including a CSS file in React would result in a manifest value
				// starting with `js/../css/`, so this gets replaced with just `css/` here
				value: entry.value.startsWith('../') ? entry.value.replace(/^\.\.\//, '') : `${manifestPrefix}/${entry.value}`
			};
			
			//console.log(e);
			return e;
		},
		done() {
		    require('./reload-assets.js').reload();
		},
		// this is required to make the output path relative to config.output.path
		output: path.join(webFiles[i].output.path.replace(outBase, '')
			.replace(new RegExp(`^\\${path.sep}`), '')
			.replace(new RegExp(`[^\\${path.sep}]+`, 'g'), '..'),
		`assets-manifest.json`)
	}));
}


module.exports = [
	...webFiles
];